# Паттерны, антипаттерны написания кода.
---
---
## 1. Что такое паттерн?
---
`Паттерн - это набор правил согласно, которым программист проектирует какую-либо функцию, модуль, API или проект`

### Паттерн можно сравнить с формулой в математике - нам нет необходимости каждый раз выводить формулу для решения какой-либо задачи. Достаточно - найти её в справочнике, а по ней решить проблему.

## 2.DRY, KISS, YAGNI.
---
Для начинающего разработчика можно выделить три основных паттерна проектирования, которые подходят для любого языка и платформы:

### 1.DRY - Don't repeat yourself.

`TRY(НЕ ПОВТОРЯЙ СЕБЯ) - паттерн призывает не повторяться при написании кода.`

Паттерн стоит использовать там, где это необходимо, т.к. он может без проблем обратиться в антипаттерн.
Может возникнуть ситуация, когда написание кода в 10 строчек приводит к увеличению кода в 50 строк, которые используются всего пару раз.

### 2. KISS - keep it short simple.

`KISS(ДЕЛАЙТЕ ВЕЩИ ПРОЩЕ) - паттерн призывает не создавать сложную логику.`

Порой достаточно отдохнуть от сложной задачи и прийти к тому, что она решается очень легко. Не усложняй задачу!

### 3. YAGNI - you ain't gonna need it.

`YAGNI(ВАМ ЭТО НЕ ПОНАДОБИТСЯ) - паттерн призывает следовать техническому заданию и не добавлять излишнюю логику`

Когда мы делаем конкретную задачу - то мы делаем только её. Нет необходимости добавлять излишний функционал, который потратит ваше время и увеличит код.

## 3. SOLID.
---
Как только разработчик познакомиться с ООП, то стоит почитать о принципе SOLID. Он позволяет легче масштабировать и поддерживать проект.

### 1. S - Single Responsibility(Принцип единственной ответственности).

![1](https://habrastorage.org/r/w1560/webt/ug/2v/ts/ug2vtsbxvspdx0elsmexemp3kxm.png)


`Каждый класс должен отвечать только за одну операцию`

#### Назначение - принцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, не распространялись на прочие, не связанные с ним типы.

Если класс отвечает за несколько операций сразу, вероятность возникновения багов возрастает внося изменения, касающиеся одной из операций вы, сами того не подозревая, может затронуть и другие.

### 2. O - Open-Closed(Принцип открытости-закрытости).

![2](https://habrastorage.org/r/w1560/webt/ir/sm/eb/irsmeboddq2dcx1eaky5qo83v64.png)

`Добавляйте новый функционал классу не трогая старый.`

#### Назначение - принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс.

Если класс ломается после добавления нового функционала, то стоит пересмотреть его логику. Где-то стоит её подправить, чтобы функционал был блочным.

### 3. L - Liskov Substitution(Принцип подстановки Барбары Лисков).

![3](https://habrastorage.org/r/w1560/webt/hj/dt/a-/hjdta-bs2bvk2ga_dabxajfqjnk.png)

`Потомок родителя должен иметь возможность выполнять тот же функционал, что и родитель`

#### Назначение - принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым образом без нарушения работы программы.

Если потомок-класса не способен использовать функционал родителя, то нам будет необходимо создать где-то еще функционал для него. А это нарушение одновременно принципа SOLID и DRY.

### 4. I - Interface Segregation(Принцип разделения интерфейсов).

![4](https://habrastorage.org/r/w1560/webt/v8/co/dn/v8codny8xpy355zcqvfro-7ep8a.png)

`Не следует добавлять в класс методы, которые в нём не используются`

#### Назначение - принцип служит для того, чтобы раздробить единый набор действия на ряд наборов поменьше. Таким образом, каждый класс делает то, что от него действительно требуется, и ничего больше.

Когда классу приходится производить действия, не несущие никакой реальной пользы, это выливается в пустую трату ресурса, а в случае, если класс выполнять эти действия не способен, ведёт к возникновению багов.

Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем.

### 5. D - Dependency Inversion(Принцип инверсии зависимостей).

![5](https://habrastorage.org/r/w1560/webt/du/7r/0u/du7r0use6rfrrqr8wc9a2qcvf2y.png)

`Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций`

- Модули верхнего уровня - классы, которые выполняют операцию при помощи инструмента
- Модули нижнего уровня - инструменты, которые нужны для выполнения операций
- Абстракции - интерфейс, соединяющий два класса
- Детали - специфические характеристики работы инструмента

#### Назначение - этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.

Согласно данному принципу, класс не должен соединяться с инструментом, который применяет для выполнения операции. Вместо этого он должен быть соединён с интерфейсом, который поможет установить связь между инструментом и классом.

Кроме того, принцип гласит, что ни интерфейс, ни класс, не обязаны вникать в специфику работы инструмента. Напротив, это инструмент должен подходить под требования интерфейса.