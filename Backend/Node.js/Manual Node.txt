Node.js - программная платформа, основанная на движке V8(на котором делали Chrome), которая написана
на языке JavaScript и C++. Она по сути дополняет JavaScript дополнительными фичами: создание сервера, работа
с файлами и т.п.

Node.js работает вместе с пакетным менеджером npm. Служит для установки и менеджмента различных дополнительных
пакетов в этом приложении.

Чтобы проинициализировать проект вводим команду npm init и заполняем поля. После этого создаться файл package.json,
в котором будут все поля, которые мы заполняли при инициализации. Данный файл хранит список зависимостей для
нашего приложения. То есть дополнительные пакеты для Node.js.
После установки дополнительно пакета, в файле package.json появляется поле dependencies,
которое является объектом, где ключ соответствует названию пакета, а значение его версии.
По-мимо этого в проекте появляется папка node_modules, в которой как и появляется новый пакет.
Один пакет имеет завимсимости от другого, поэтому по-мимо одного пакета, ставятся еще и другие.

Также файл package.json нужен для того, чтобы показать какие зависимости есть в проекте, чтобы не передавать проект
другому человеку вместе с папкой node_modules.
Когда человек получает проект, то просто пишет в терминале команду npm i , а пакетный менеджер обращается к файлу
package.json и устанавливает все зависимости.

"dependencies": {
    "chalk": "^5.0.1"
  },
  "devDependencies": {
    "nodemon": "^2.0.18"

1.Общая информация.
==================================================================================================
Node.js это платформа, которая расширяет JavaScript. Она позволяет работать JavaScript с устройствами ввода/вывода
через свой, специально написанный, API написанный на C++.

Задача Node.js в преобразовании JavaScript в машинный код, с помощью движка V8.
V8 занимается выделением памяти для объектов и занимается сборкой мусора. Удаляет из памяти объекты, которые
больше не нужны.
По-мимо движка V8 есть еще библиотека Libuv. Она отвечает за:
-Кроссплатформерный I/O (ввод-вывод) - позволяет использовать Node.js на любой OS.
Работа с файловой системой, сетью
-Цикл событий(Event Loop)

2.Блокирующий ввод/вывод.
==================================================================================================
При данном сценарии, создается поток(или несколько потоков), которые выполняют конкретный запрос
с веб-сервера.
Минус в том, что поток может простаивать, или наооборот, выполнять запрос слишком долго
в итоге скорость выполнения всех запросов падает.
Другой запрос в поток не попадает, пока не выполнит предыдущий.
При этом потоки потребляют большое количество ресурсов и памяти.

Пример блокирующего веб-сервера - Apache.

3.Неблокирующий ввод/вывод.
==================================================================================================
При данном сценарии, создается главный поток(main thread), который обрабатывает все запросы
с веб-сервера.
Системные вызовы немедленно возвращают управление, не ожидая выполнения чтения или записи данных.
Также, при этом поток не блокируется.

Пример неблокирующего веб-сервера - nginx.

5.Двойственность Node.js.
==================================================================================================
По факту Node.js является неблокирующим, но благодаря библиотеке Libuv, он может работать, и как
блокирующий.
Libuv по дефолту имеет 4 потока, но в настройках их можно добавить.

Libuv написан на C.
V8 написан на C++.

Благодаря этому можно писать дополнительные модули, которые могут использовать потоки, для Node.js.

С потоками, внутри операционной системы, работает Планировщик потоков(Thread scheduler). Он выделяет
потокам определенное количество ресурсов.

С версии node.js 11.7.0. можно управлять потоками из кода с помощью модуля worker_threads.

6.Демультиплексор событий.Шаблон Reactor.
==================================================================================================
Демультиплексор событий - представляет из себя интерфейс уведомления о событиях.
Его задача - собрать и поставить в очередь события ввода/вывода.
А также блокировка новых, поступающих от приложения.

Event Loop(Цикл событий) - бесконечный цикл, которые выполняет события из Очереди событий.

Очередь выполнения событий:
1.Задача попадает в Call stack(Стакан вызова).
2.Если задача не может выполнится в данный момент, то она попадает в Callback queue(Очередь задач),
где ждет своей очереди.
Также, отдельно хранятся и выполняются события, которые не привязаны к обычному JS, а например к WEB API.

Внутри Node.js обработчик, внутри очереди событий, представлена в виде функции Callback.

Принцип работы приложения в шаблоне Reactor:

1.Приложение создает операцию ввода/вывода и передает запрос Демультиплексору.
Также, приложение должно определить обработчик. Обработчик будет вызван тогда, когда операция будет завершена.
Демультиплексор в это время делает повторный запрос приложению на новое событие.
При этом приложение не блокируется.
2.После завершения набора операций ввода/вывода Демультиплексор добавляет эти события в очередь событий.
3.Event Loop проходит обход событий.
4.Для каждого события вызывается обработчик в приложении.
5а.Обработчик возвращает управление Event Loop.
5b.Обработчик возвращает управление приложению, а оно получает новый запрос ввода/вывода.
6.Весь цикл заканчивается, когда Event Loop выполняет последнее событие и обратиться к Демультиплексору событий.


Демультиплексор событий:
1.Linux - epoll.
2.Windows - I/O Completion Port(IOCP)
3.Mac OS - kqueue.

Порядок выполнения событий Event Loop в Node.js:

1.Таймеры. - выполняются callback, связанные с SetTimeOut и SetInterval.
2.I/O Callbacks. - выполняются все callback, за исключением событий close, таймеров и setImmediate.
3.Ожидание, подготовка. - слубежная фаза.
4.Опрос. - получение новых событий ввода/вывода.
5.Проверка. - setImmediate.
6.Callbacks "close".

7.Модули Node.js.
==================================================================================================

7.1. Process
==================================================================================================
Process - глобально доступный объект. С помощью него мы можем получить некоторую информацию о текущем процессе.
Например:

1)Уникальный идентификатор процесса

console.log(process.pid) - команда выведет в консоль ID процесса, запускаемой программы.
При каждом запуске программы ID будет меняться.

Запуск бесконечного цикла:

console.log(process.pid)

while(true){
    
}

В командной строке нам покажут номер процесса.
Чтобы закрыть процесс извне, можно зайти в новый терминал и ввести команду kill номерпроцесса.

2)Переменные окружения:

Свойство env объекта process позволяеть обращаться к переменным OS.

Переменные бывают:
1)Локальные - относятся к конкретной сессии.
2)Пользовательские - доступны конкретным пользователям.
3)Глобальные - доступны всем пользователям.

console.log(process.env) - команда покажет в логах какие переменные будут задействованы, при запуске приложения.

Некоторые переменные мы можем изменять, добавлять. Например:

console.log(process.env.PORT) - указать порт.
console.log(process.env.NODE_ENV) - режим разработки(например development или production).

Чтобы их использовать, необходимо также подключить приложение(index.js или любое другое) к файлу package.json. 
Работает только с пакетов cross-env.

 "scripts": {
    "start": "cross-env PORT=5000 NODE_ENV=development node index.js"
  },

Внутри скрипта мы можем сами указать значение переменной.

Переменные можно также объявить в отдельном файле .env(без расширения).
Работает с пакетом dotenv.

Импортируем dotenv в приложение, чтобы соединить с файлом .env

require('dotenv').config()
console.log(process.env)

console.log(process.env.PORT);
console.log(process.env.NODE_ENV);

3)process.argv

При запуске приложения из терминала/командной строки мы можем передавать ему параметры.
Для получения параметров в коде приложения применяется массив process.argv. 
Это аналогично тому, как в языках C/C++/C#/Java в функцию main передается набор аргументов в виде строкового массива.

Первый элемент этого массива всегда указывает на путь к файлу node.exe, который вызывает приложение. 
Второй элемент массив всегда указывает на путь к файлу приложения, который выполняется.

К примеру, определим следующий файл app.js:

let nodePath = process.argv[0];
let appPath = process.argv[1];
let name = process.argv[2];
let age = process.argv[3];
 
console.log("nodePath: " + nodePath);
console.log("appPath: " + appPath);
console.log();
console.log("name: " + name);
console.log("age: " + age);

В данном случае мы ожидаем, что приложению будут переданы два параметра: name и age.

Теперь запустим приложение с помощью следующей команды:
node app.js Tom 23

В данном случае "Tom" и "23" - это те значения, которые помещаются соответственно в process.argv[2] и process.argv[3]:

4)Path,URL.

Path:

const path = require('path');

console.log('Склеить участки пути' , path.join(__dirname, 'first', 'second', 'third'))
console.log('возвращает абсолютный путь', path.resolve('first', 'second', 'third'))
console.log('Парсинг пути', path.parse(fullpath))
console.log('Разделить в OS', path.sep)
console.log('Проверка на абсолютный путь', path.isAbsolute('first/second'))
console.log('Название файла', path.basename(fullpath))
console.log('Расширение файла', path.extname(fullpath))

URL:

const siteURL='http://localhost:8080/users?id=5123'
const url = new URL(siteURL);
console.log(url)

5)Файловая система.Работа с файлами.CRUID.

Создание папки при неблокирующем потоке(рекурсивном):

const fs = require('fs')
const path = require('path')

fs.mkdirSync(path.resolve(__dirname,'dir','dir3','dir4'), {recursive:true})

Создание папки при блокирующем потоке:

