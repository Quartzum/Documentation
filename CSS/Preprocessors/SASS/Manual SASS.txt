SASS - это препроцессор для CSS. То есть он расширяет возможности CSS и добавляет новые фишки.

ОСОБЕННОСТЬ:
При использовании функции @import с обычными css файлами мы будем генерировать столько запросов, сколько
сделаем вызовов @import.
А при использовании @import с sass файлами, мы используем всего лишь один HTTP запрос, т.к. все sass файлы
будут компилироваться в один css.
В итоге получим возможность разбивать наш код на маленькие части(extents,reset,var и т.п.)
Есть две разновидности SASS:
1)SASS - старая версия SASS, которая использует отступы, вместо фигурных скобок.
2)SCSS - новая версия, которая использует ; вместо отступов.

Sass может использоваться тремя путями:

Как инструмент в командной строке
Как отдельный модуль Ruby
Как модуль для любого, поддерживающего Rack, фреймворка, в том числе Ruby On Rails и Merb

1)Переменные.
==================================================================================================
Переменная - это контейнер, который хранит внутри себя свойство селекторов.

$ - объявление переменной.

Пример:

$colorBlack: black;

body{
    color:$colorBlack;
}

2)Вложенности.
==================================================================================================
Вложенности - работает по такому же принципу, как и в HTML. Но лучше не злоупотреблять этим методом,
т.к. это делает код менее читабельным.

nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}

3)Фрагментирование.
==================================================================================================
Вы можете создавать фрагменты Sass-файла, которые будут содержать в себе небольшие отрывки CSS,
которые можно будет использовать в других Sass-файлах. Это отличный способ сделать ваш CSS модульным,
а также облегчить его обслуживание. Фрагмент — это простой Sass-файл, имя которого начинается с нижнего
подчеркивания, например, _partial.scss. Нижнее подчеркивание в имени Sass-файла говорит компилятору о том,
что это только фрагмент и он не должен компилироваться в CSS.
Фрагменты Sass подключаются при помощи директивы @import.

4)Импорт.
==================================================================================================
CSS имеет возможность импорта, которая позволяет разделить ваш CSS-файл на более мелкие и облегчить@import,
то в CSS создается еще один HTTP-запрос. Sass берет идею импорта файлов через директиву @import, но вместо 
создания отдельного HTTP-запроса Sass импортирует указанный в директиве файл в тот, где он вызывается,
т.е. на выходе получается один CSS-файл, скомпилированный из нескольких фрагментов.

Например, у вас есть несколько фрагментов Sass-файлов — _reset.scss и base.scss. И мы хотим
импортировать _reset.scss в base.scss.
Обратите внимание на то, что мы используем @import 'reset'; в base.scss файле. Когда вы импортируете файл,
то не нужно указывать расширение .scss. Sass — умный язык и он сам догадается.

// _reset.scss
html,
body,
ul,
ol {
  margin:  0;
  padding: 0;
}

// base.scss
@import 'reset';
body {
  font: 100% Helvetica, sans-serif;
  background-color: #efefef;
}

//css

html,
body,
ul,
ol {
  margin:  0;
  padding: 0;
}
body {
  font: 100% Helvetica, sans-serif;
  background-color: #efefef;
}

5)Миксины (примеси).
==================================================================================================
SCSS SYNTAX
@mixin transform($property) {
  -webkit-transform: $property;
  -ms-transform: $property;
  transform: $property;
}
.box { @include transform(rotate(30deg)); }

CSS
.box {
  -webkit-transform: rotate(30deg);
  -ms-transform: rotate(30deg);
  transform: rotate(30deg);
}

Миксины работают, как переменные, но могут включать в себя несколько свойств, в которые при помощи переменной
передается значение извне.

6)Расширение/Наследование.
==================================================================================================

Это одна из самых полезных функций Sass. Используя директиву @extend можно наследовать наборы
свойств CSS от одного селектора другому. Это позволяет держать ваш Sass-файл в «чистоте».
В нашем примере мы покажем вам как сделать стили оповещений об ошибках, предупреждениях и удачных исходах, 
используя другие возможности Sass, которые идут рука-об-руку с расширением, классами-шаблонами. 
Класс-шаблон - особый тип классов, который выводится только при использовании расширения - это позволит сохранить
ваш скомпилированный CSS чистым и аккуратным.

SCSS Input

/* This CSS will print because %message-shared is extended. */
%message-shared {
  border: 1px solid #ccc;
  padding: 10px;
  color: #333;
}

// This CSS won't print because %equal-heights is never extended.
%equal-heights {
  display: flex;
  flex-wrap: wrap;
}

.message {
  @extend %message-shared;
}

.success {
  @extend %message-shared;
  border-color: green;
}

.error {
  @extend %message-shared;
  border-color: red;
}

.warning {
  @extend %message-shared;
  border-color: yellow;
}


CSS OUTPUT
.message, .success, .error, .warning {
  border: 1px solid #ccc;
  padding: 10px;
  color: #333;
}

.success {
  border-color: green;
}

.error {
  border-color: red;
}

.warning {
  border-color: yellow;
}


Особенность:

Многие используют миксин, как каркас для импорта в него extends. То есть, мы можем создать большой миксин,
в который динамически будем передавать данные. Внутри него пропишем свойства, в которые эти данные будут передаваться,
а также то, что не будет передаваться динамически занесем через переменные или extends.

Это нужно для того, чтобы свойства при компилировании в css не захламляли код, т.к. при вызове миксина свойства
будут дублироваться.

7)Математические операторы.
==================================================================================================
Использовать математику в CSS очень полезно. Sass имеет несколько стандартных математических операторов,
таких как +, -, *, / и %. В нашем примере мы совершаем простые математические вычисления
для расчета ширины aside и article.