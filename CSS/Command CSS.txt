1)Виды селекторов:
==================================================================================================
body {} - селектор по тегу.
#kads{} - селектор по ID.
.menu{} - селектор по классу.
img[alt]{} - селектор по атрибуту. 
Также есть еще разновидность: img[alt="type"]{}. То есть можно выбрать даже по значению.
.message:hover{} - событийный селектор.(этот принцип можно использовать 
и при поиске по тегу,ID и классу).


2)Комментарии:
==================================================================================================
/* Текст */ - комментарии в CSS.

3)Единицы измерения в CSS:
==================================================================================================
1)Относительные:

1.px - пиксель.

Плюсы
-четкость и понятность

Минусы
- Другие единицы могут устанавливать соотношения между различными размерами

2.% - процент.
Берется от свойства родителя.

3.em - высота текущего шрифта

2)Абсолютные:

cm - сантиметр;
mm – миллиметр;
in - дюйм;
pt - пункт;
pc - пика.

К абсолютным единицам относятся единицы измерения, которые используются в обычной жизни. Но
они в веб-страницах используются достаточно редко, поэтому их использовать крайне нежелательно.

4)Вложенность:
==================================================================================================
1.Контекстные селекторы:
HTML - часть

<p class= ”main” >В этом параграфе
<strong><a href=“#”> эта ссылка </a></strong> будет
размером 18px и красного цвета,
<a href = ”#” > а эта будет обычной </a>.
</p>

CSS - часть

.main strong a {
font-size: 18px ;
color: red;
}

В этом примере можно увидеть параграф с классом main. В параграф вложена ссылка. Этой ссылке
задаем определенный стиль. Обратимся к этой ссылке при помощи контекстного селектора. Для этого
в качестве селектора сначала указывается тег параграфа с классом main, затем ставится пробел и
следующим указывается тег strong, после этого обращаемся к тегу нужной нам ссылки. Таким
образом, заданный стиль будет применяться ТОЛЬКО к первой ссылке в параграфе с классом main.

2.Дочерние селекторы:
HTML- часть

<p class= ”main” >
<a href=“#”> ссылка 1 </a>
</p>
<p class= ”main” >
<i><a href=“#”> ссылка 2 </a></i>
</p>

CSS-часть

.main > a {
font-size: 18px ;
color: red;
}

При помощи дочерних селекторов можно выбрать только те теги, которые являются прямыми
потомками определенного элемента. В этом примере в первом параграфе ссылка является дочерним
элементом для этого параграфа, т.к. вложена только в параграф. А во втором параграфе ссылка для
параграфа не будет являться дочерним элементом, т.к. она вложена в тег i, и, соответственно, будет
являться дочерним элементом для тега i. А тег i для этой ссылки будет родительским элементом. В
разделе CSS кода после обращения к селектору параграфа р с классом main ставится знак больше, а
затем тег а, это означает, что необходимо обратиться к дочернему тегу ссылки параграфа с классом
main. В этом примере такому запросу соответствует ссылка в первом параграфе, и ТОЛЬКО данной
ссылке будет применен заданный стиль.

3.Соседние селекторы:
HTML-часть

<p class= ”main” >
<a href=“#”> ссылка 1 </a>
</p>
<p class= ”main” >
<i> Соседний элемент </i>
<a href=“#”> ссылка 2 </a>
</p>

CSS-часть

.main i + a {
font-size: 18px ;
color: red;
}

Для демонстрации работы соседних селекторов изменим предыдущий пример. Ссылка 2 теперь
будет не вложена в тег i, а находиться рядом, т.е. будет являться для тега i соседним элементом. Для
того, чтобы обратиться к этой ссылке и задать ей определенный стиль, в разделе CSS кода после
тега i надо поставить знак плюс, а затем указать тег ссылки. В этом случает ТОЛЬКО ссылка 2
приобретет заданный стиль.

5)Наследование:
==================================================================================================
Наследование - это перенос стилей от элемента к вложенным в него тегам.

HTML-часть

<p> В этом параграфе весь текст <b> будет </b> красного
цвета и шрифтом <b><i> размером 18 px </i><b>
</p>

CSS-часть

p {
font-size: 18px ;
color: red;
}

В данном примере в тег <p> вложены теги два тега <b>, в один из которых также вложен тег <i>. В
этом случае весь текст в этом параграфе будет заданного стиля. То есть, все теги, вложенные в
параграф, унаследовали заданный стиль. Но не все свойства CSS наследуются.

HTML-часть

<p> В этом параграфе весь текст <b> будет </b> красного
цвета и шрифтом <b><i> размером 18 px </i></b>, только
<a href=“#”> эта ссылка </a> не будет красной
</p>

CSS-часть

p {
font-size: 18px ;
color: red;
}

Если добавить в этот пример еще и ссылку, то эта ссылка унаследует только свойство font-size, но
свойство color не унаследует. Узнать, наследуется ли определенное свойство CSS или нет, можно
узнать только из справочников. В данном примере, чтобы применить к ссылке свойство color также,
как у всех остальных элементов, можно для этой ссылки задать значение inherit для свойства color.
inherit означает, что элементу необходимо наследовать данное свойство от родителя.

6)Группировка свойств и селекторов:
==================================================================================================
Стоит использовать, чтобы не повторять код. Если где-то хотя бы раз, код повторяется,
то необходимо его убрать и сгруппировать с другими свойствами. Также делают и с селекторами.

7)Принцип работы каскадных таблиц:
==================================================================================================
Всё что находится на последних строчках кода, будет выполняться в первую очередь.
То есть если в начале был например задан один цвет текста, в конце другой. 
То выполняться будет самый последний.

8)Приоритеты источников стилей:
==================================================================================================
1. Стиль автора документа обладает самым высоким приоритетом. Этот стиль задает сам
разработчик сайта.
2. Стиль, заданный пользователем в настройках браузера. Стиль CSS может задать конечный
пользователь этого сайта, если подключит свой собственный файл стилей. Этот источник
является менее приоритетным.
3. Стиль самого браузера, т.е. тот стиль, который определен в настройках самого браузера. Это
источник обладает самым низким приоритетом.

Для того, чтобы поставить важность свойства, необходимо указать всё следующим образом:

p{
color:green!important;
}

Данная директива будет выполняться в первую очередь.

Вторым по приоритетности является стиль, объявленный в атрибуте style любого тега.

HTML-код

<h1 style= ”color: red; ” >
Заголовок первого уровня
</h1>

CSS-код

h1 {
color: green;
}

В данном примере цвет текста заголовка первого уровня будет красным, так как этот стиль
переопределен в атрибуте style.

Следующий уровень, это уровень приоритета селекторов. Существует такое понятие, как
специфичность. Смысл его в том, что браузер будет начислять определенное количество баллов за
разные типы селекторов, а также их количество. И больший приоритет получают те стили, которые
набирают большее количество баллов.

9)Свойства селекторов:
==================================================================================================

1)Текст:
==================================================================================================
1.width: 100%; - ширина элемента.
2.height: 100%; - высота элемента.
3.Если содержимое блока будет превышать высоту блока, то блок останется неизменным,
а содержимое выйдет за его рамки. Чтобы такого не происходило надо применить свойство: overflow: auto.
4.font-family - семейство шрифтов.
5.font-style - стиль шрифта(normal or italic).
6.font-variant - имеет только 2 значения, по умолчанию установлено значение normal и small-caps,
которое у строчных букв имитирует заглавные буквы, только уменьшенного размера.  
7.font-weight - жирность шрифта.(еще можно указывать так bold - полужирный, bolder - жирный, lighter - светлый.)
8.font-size - размер шрифта
9.text-align - выравниванье текста в элементе.
    
2)Работа с цветом:
==================================================================================================
color - цвет текста.

3)Рамки:
==================================================================================================
1.border - рамка объекта(первый параметр - толщина(1px), второй параметр - тип рамки, третий параметр - цвет).
Есть возможность каждую границу задавать отдельно, когда необходима, к примеру, только одна
граница.
2.border-top - рамка сверху.
3.border-bottom - рамка снизу.
4.border-left - рамка слева.
5.border-right - рамка справа.
6.border-color - цвет рамки.
7.border-style - стиль рамки, которая может быть разных значений, такие как: dotted, dashed,
solid, double, groove, ridge, inset, outset. border-width задает толщину рамки, причем ее можно
задать для каждой из 4 сторон отдельно:
(1px 2px) - 1px: верхняя и нижняя, 2px: левая и правая
(1px 2px 3px) - 1px: верхняя, 2px: левая и правая, 3 нижняя
(1px 2px 3px 4px) - 1px: верхняя, 2px: правая, 3px: нижняя, 4px: левая
8.border-radius - закругление элемента.

4)Работа с расположением тега:
==================================================================================================
1.margin - внешний отступ(в параметры принимает значения с 4 сторон в пикселях).
2.margin-left - внешний отступ слева.
3.margin-right - внешний отступ справа.
4.margin-top - внешний отступ сверху.
5.margin-bottom - внешний отступ снизу.
    
1.padding - внутренний отступ(в параметры принимает значения с 4 сторон в пикселях).
2.padding-left - внутренний отступ слева.
3.padding-right - внутренний отступ справа.
4.padding-bottom - внутренний отступ снизу.
5.padding-top - внутренний отступ сверху.
    
5)Свойства display:
==================================================================================================
/* <display-outside> values */
1.display: block;  -Элемент показывается как блочный. 
Применение этого значения для встроенных элементов, например тега <span>, 
заставляет его вести подобно блокам — происходит перенос строк в начале и в конце содержимого.
2.display: inline; - Элемент отображается как встроенный. Использование блочных тегов, таких как <div> и <p>, автоматически создает перенос и показывает
содержимое этих тегов с новой строки. Значение inline отменяет эту особенность, поэтому содержимое блочных элементов начинается с того места, 
где окончился предыдущий элемент.
3.display: run-in; - Устанавливает элемент как блочный или встроенный в зависимости от контекста.

/* <display-inside> values */
display: flow;
display: flow-root;
display: table;
display: flex;
display: grid;
display: ruby;

/* <display-outside> plus <display-inside> values */
display: block flow;
display: inline table;
display: flex run-in;

/* <display-listitem> values */
display: list-item;
display: list-item block;
display: list-item inline;
display: list-item flow;
display: list-item flow-root;
display: list-item block flow;
display: list-item block flow-root;
display: flow list-item block;

/* <display-internal> values */
display: table-row-group;
display: table-header-group;
display: table-footer-group;
display: table-row;
display: table-cell;
display: table-column-group;
display: table-column;
display: table-caption;
display: ruby-base;
display: ruby-text;
display: ruby-base-container;
display: ruby-text-container;

/* <display-box> values */
display: contents;
display: none;

/* <display-legacy> values */
1.display: inline-block; -Это значение генерирует блочный элемент, который обтекается другими элементами веб-страницы подобно встроенному элементу. 
Фактически такой элемент по своему действию похож на встраиваемые элементы (вроде тега <img>). 
При этом его внутренняя часть форматируется как блочный элемент, а сам элемент — как встроенный.
2.display: inline-table;
3.display: inline-flex;
4.display: inline-grid;

/* Global values */
display: inherit;
display: initial;
display: unset;

6)Работа с изображениями:
==================================================================================================
1.background : #ff0 url(img/photo.jpg) top repeat-x; - сокращенная запись всего того, что снизу.
2.background-color:; - цвет фона.
3.background-image: url(images/doom_2016.jpg); - вставка картинки.
4.background-position - указывает где будет располагаться фоновое изображение. Может иметь
значения: top, bottom, left, right. background-repeat определяет, нужно ли повторять фоновое
изображение. repeat-x - изображение повторяется по горизонтали, repeat-y - по вертикали,
no-repeat - изображение не повторяется. По умолчанию у этого свойства установлено
значение repeat, что означает, что изображение будет повторяться по горизонтали и по
вертикали.
background-attachment - определяет, будет ли изображение прокручиваться вместе с
содержимым элемента. По умолчанию, оно установлено как scroll, что означает, что
изображение будет прокручиваться, а при значении fixed, изображение будет оставаться
неподвижным.
   
7)Эффекты:
==================================================================================================
1.opacity: 1; - видимость элемента(1-видимый, 0,5-наполовину, 0 - невидимый).
2.box-shadow: 3px 3px 3px blue; - задает тень объекту.
(сдвиг по оси х, свдиг по оси у, размытие тени, цвет).
Сдвиги по оси можно делать влево и вправо, для этого надо использовать либо -3px, либо 3px.
3.display: block; - убирает видимость или невидимость элемента(none - не видим элемент).

8)Анимация:
==================================================================================================
1.transform: rotate(34deg);- свойство трансформации. Позволяет задать элементу анимацию.
(rotate - поворот, на определенный градус, который пишется в скобках).
2.transform: scale(1.0) - увеличивается или уменьшает элемент.
3.transition: 5s all; - задает промежуток времени, для определенного свойства
(вместо all может быть например transform).

9)Работа с ссылками:
==================================================================================================
text-decoration: none; - отключение подчеркиванья у ссылки.

10)Работа со списками:
==================================================================================================
1.list-style-type:;-тип маркера(значение none убирает маркеры)
2.list-style-position определяет то, где располагается маркер, по умолчанию у него значение
outside. В этом случае маркеры будут располагаться за пределами текстового блока. При
значении inside, наоборот, внутри текстовых блоков.
3.list-style-image позволяет вместо маркера установить изображение, для этого нужно указать к
нему путь в скобках url.

Сокращенная запись:
list - style : list - style - type

Порядок:
list - style - position
list - style - image;
list - style : circle inside;

11)Работа с таблицами:
==================================================================================================
padding:; - внутренние отступы.
border-spacing:; - внешние отступы.

Примечания по работе с таблицами:

/*Внешняя граница таблицы*/
table {
border : 1px solid #000;
}
/*Границы для ячеек таблицы*/
td {
border : 1px solid #000;
}

Ширину и высоту таблицы задаем при помощи свойств CSS width и height.

table {
width : 400px;
height : 200px;
}

По умолчанию ширина и высота таблицы определяется содержимым её ячеек. Если не задать
ширину, то она будет равна ширине самого широкого ряда
Ширину таблицы и её столбцов можно задать с помощью свойства width. Если для таблицы задана
ширина table {width: 100%;}, то она будет равна ширине блока-контейнера, а ширина столбцов
установится в соответствии с шириной содержимого ячеек. Чаще всего ширину таблицы и столбцов
задают в px или %.
Высота таблицы обычно не задается. Высотой строк таблицы можно управлять, добавив верхний и
нижний padding, или же задав высоту с помощью свойства height.

Внешние отступы (border-spacing) можно задать либо всем 4 сторонам, либо отдельно. В этом случае
первое значение будет действовать для левой и правой сторон, а второе - для верхней и нижней.
Внутренние отступы (padding) можно задавать и для каждой границы отдельно.
(1px 2px) - 1px: верхняя и нижняя, 2px: левая и правая.
(1px 2px 3px) - 1px: верхняя, 2px: левая и правая, 3 нижняя.
(1px 2px 3px 4px) - 1px: верхняя, 2px: правая, 3px: нижняя, 4px: левая.
Для выравнивания по горизонтали внутри ячейки существует устаревший атрибут align, который
заменяется на свойство CSS text-align.

td {
text - align : center ; ( right | justify | left)
}

Для вертикального выравнивания внутри ячейки у тега <td> существует устаревший атрибут valign.
Для его замены в CSS существует свойство vertical-align.

td {
vertical - align : top ; ( bottom | baseline | middle)
}

Есть ещё одно полезное свойство для оформления таблиц. Если для всех ячеек задать атрибут
cellspacing=”0”, или CSS свойство border-spacing=”0”, то границы соседних ячеек будут двойными. Для
того, чтобы убрать двойные границы, в CSS существует свойство border-collapse.

table {
border - collapse : collapse;
}

Свойство border-collapse может принимать два значения. По умолчанию установлено separate, при
котором рамка двойная, а при значении collapse рамка становится одинарной.

10)Псевдоклассы и псевдоэлементы:
==================================================================================================
==================================================================================================
1)Псевдоклассы:
==================================================================================================
a)Определяющие состояние элементов:

a:link — ссылается на непосещенную ссылку.
a:visited — ссылается на уже посещенную ссылку.
a:hover — ссылается на любой элемент, по которому проводят курсором мыши.
a:focus — ссылается на любой элемент, над которым находится курсор мыши.
a:active — ссылается на элемент, который был активизирован пользователем.
:valid — выберет поля формы, содержимое которых прошло проверку в браузере на соответствие
указанному типу.
:invalid — выберет поля формы, содержимое которых не соответствует указанному типу. :enabled —
выберет все доступные (активные) поля форм.
:disabled — выберет заблокированные поля форм, т.е. находящиеся в неактивном состоянии.
:in-range — выберет поля формы, значения которых находятся в заданном диапазоне.
:out-of-range — выберет поля формы, значения которых не входят в установленный диапазон.
:lang() — выбирает абзацы на указанном языке. :not(селектор) — выберет элементы, которые не
содержат указанный селектор, например, класс, идентификатор или селектор элемента
:not([type="submit"]). :target — выбирает элемент с символом #, на который ссылаются в документе.
:checked — выбирает выделенные (выбранные пользователем) элементы.

b)Структурные:

:nth-child(odd) — выбирает нечетные дочерние элементы.
:nth-child(even) — выбирает четные дочерние элементы.
:nth-child(3n) — выбирает каждый третий элемент среди дочерних.
:nth-child(3n+2) — выбирает каждый третий элемент, начиная со второго дочернего элемента (+2).
:nth-child(n+2) — выбирает все элементы, начиная со второго.
:nth-child(3) — выбирает третий дочерний элемент.
:nth-last-child() — в списке дочерних элементов выбирает элемент с указанным местоположением,
аналогично с :nth-child(), но начиная с последнего, в обратную сторону.
:first-child — позволяет оформить только самый первый дочерний элемент тега.
:last-child — позволяет форматировать последний дочерний элемент тега.
:only-child — выбирает элемент, являющийся единственным дочерним элементом.
:empty — выбирает элементы, у которых нет дочерних элементов.
:root — выбирает элемент, являющийся корневым в документе (элемент html).

c)По типу дочернего элемента:

:nth-of-type() — выбирает элементы по аналогии с
:nth-child(), при этом берет во внимание только тип элемента.
:first-of-type — позволяет выбрать первый дочерний элемент.
:last-of-type — выбирает последний тег конкретного типа.
:nth-last-of-type() — выбирает элемент заданного типа в списке элементов в соответствии с указанным
местоположением, начиная с конца.
:only-of-type — выбирает единственный элемент указанного типа среди дочерних элементов
родительского элемента.

Псевдоклассы можно комбинировать, перечисляя по порядку.

2)Псевдоэлементы:
==================================================================================================
:first-letter — выбирает первую букву каждого абзаца, применяется только к блочным элементам.
:first-line — выбирает первую строку текста элемента, применяется только к блочным элементам.
:before — вставляет генерируемое содержимое перед элементом.
:after — добавляет генерируемое содержимое после элемента.




    
    
   
    
    


