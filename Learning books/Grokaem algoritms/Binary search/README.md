## Бинарный поиск
---
---
## Бинарный поиск - это алгоритм; на входе он получает `отсортированный список элементов`. Если элемент, который вы ищите, присутствует в списке, то бинарный поиск `возвращает ту позицию, в которой он был найден.` В противном случае бинарный поиск возвращает `null`.

### 1. Принцип работы бинарного поиска,  и где его использовать.
---
#### Принцип работы:
Принцип буду рассматривать на примере массива и искомого числа внутри него.
```
- Создается массив с произвольным количеством данных, и переменная с искомым числом.
- Создается функция, которая принимает в себя массив и искомое число.

- Внутри тела алгоритма создается:
1. Переменная low - начало массива, и high - конец массива.
2. Цикл while с условием, что пока low <= high, то тело цикла будет выполняться.

- Внутри тела while:
1. Создается переменная mid = (low + high) / 2.
Этой переменной мы сокращаем сокращаем массив вдвое.
2. Создаются три условия:
- if(searching == array[mid]) return mid;
Если искомое число = текущему числу середины массива, то возвращаем индекс, на котором он находится(или что-либо еще). По факту, это условие самое главное, т.к. после того, как оно выполняется, то функция заканчивает свою работу.
- else if(searching < array[mid]) high = mid-1;
Если искомое число < текущего числа середины массива, то мы переопределяем границу конца массива.
- else low = mid + 1;
Если ни одно условие не срабатывает, то мы переопределяем границу начала массива.

- Во всех остальных случаях, когда искомых значений нет, то цикл заканчивается и возвращает null.
```
Игра:я загадал число от 0 до 100. Вы должны угадать число и при каждой попытке мы говорим: "мало", "много" или "угадал".

Предположим, вы начинаете перебирать все варианты подряд: 1,2,3,4...и так до 100.
Если мы будем их перебирать подряд, то это может занять аж целых 99 попыток!
Этот поиск можно еще назвать - простым поиском.

`А как можно решить эту задачу более эффективно?`

1. Начинаем с 50 - слишком мало.
- Но мы исключили `половину чисел`
- Также мы узнали, что число `больше 50`
2. 75 - слишком много.
- Но мы опять исключили `половину чисел`
- Также мы узнали, что число `меньше 75`

`В бинарном поиске мы каждый раз берём число в середине диапазона и исключаем половину оставшихся чисел`

3. 63 - слишко много.
4. 57 - да.

Там работает бинарный поиск.

#### Основные моменты при работе с бинарным алгоритмом:
- При каждой итерации отсекается половина чисел

Например выше указанный алгоритм найдет решение не более чем за `7 попыток`.

Еще один пример - сколько нужно итераций для того, чтобы пройтись по словарю из 240 000 элементов?

- `Минимум - 1`
- `Максимум - 18`

`А если бы это был обычный алгоритм, то максимум итераций мог бы быть - 240 000`

### 2.Эффективность бинарного алгоритма.
---
В общем случае для списка из n элменетов бинарный поиск выполняется за log n по основанию 2, тогда как просто поиск будет выполнен за n шагов.

#### Логарифм

Например - log100 по основанию 10 по сути означает, сколько раз нужно перемножить 10, чтобы получить 100.
`Правильный ответ - 2: 10 * 10;`

Логарифм по смыслу противоположен возведению в степень.
Пример:

- 10 в 2 степени = 100;
- log100 по основанию 10 = 2

### 3. Как применять логарифм для бинарного поиска.
---
1. Для 8 элементов:
- Простой алгоритм - `n = 8`;
- Бинарный алгоритм - `log по основанию 8 = 3`

2. Для 1024 элементов:
- Простой алгоритм - `n = 1024`;
- Бинарный алгоритм - `log по основанию 1024 = 10`;

#### ВАЖНО!!! - бинарный поиск работает только, если список отсортирован!
