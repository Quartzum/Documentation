## Бинарный поиск
---
---
## Бинарный поиск - это алгоритм; на входе он получает `отсортированный список элементов`. Если элемент, который вы ищите, присутствует в списке, то бинарный поиск `возвращает ту позицию, в которой он был найден.` В противном случае бинарный поиск возвращает `null`.

### 1. Принцип работы бинарного поиска,  и где его использовать.
---
#### Принцип работы:
Принцип буду рассматривать на примере массива и искомого числа внутри него.
```
- Создается массив с произвольным количеством данных, и переменная с искомым числом.
- Создается функция, которая принимает в себя массив и искомое число.

- Внутри тела алгоритма создается:
1. Переменная low - начало массива, и high - конец массива.
2. Цикл while с условием, что пока low <= high, то тело цикла будет выполняться.

- Внутри тела while:
1. Создается переменная mid = (low + high) / 2.
Этой переменной мы сокращаем сокращаем массив вдвое.
2. Создаются три условия:
- if(searching == array[mid]) return mid;
Если искомое число = текущему числу середины массива, то возвращаем индекс, на котором он находится(или что-либо еще). По факту, это условие самое главное, т.к. после того, как оно выполняется, то функция заканчивает свою работу.
- else if(searching < array[mid]) high = mid-1;
Если искомое число < текущего числа середины массива, то мы переопределяем границу конца массива.
- else low = mid + 1;
Если ни одно условие не срабатывает, то мы переопределяем границу начала массива.

- Во всех остальных случаях, когда искомых значений нет, то цикл заканчивается и возвращает null.
```
Игра:я загадал число от 0 до 100. Вы должны угадать число и при каждой попытке мы говорим: "мало", "много" или "угадал".

Предположим, вы начинаете перебирать все варианты подряд: 1,2,3,4...и так до 100.
Если мы будем их перебирать подряд, то это может занять аж целых 99 попыток!
Этот поиск можно еще назвать - простым поиском.

`А как можно решить эту задачу более эффективно?`

1. Начинаем с 50 - слишком мало.
- Но мы исключили `половину чисел`
- Также мы узнали, что число `больше 50`
2. 75 - слишком много.
- Но мы опять исключили `половину чисел`
- Также мы узнали, что число `меньше 75`

`В бинарном поиске мы каждый раз берём число в середине диапазона и исключаем половину оставшихся чисел`

3. 63 - слишко много.
4. 57 - да.

Там работает бинарный поиск.

#### Основные моменты при работе с бинарным алгоритмом:
- При каждой итерации отсекается половина чисел

Например выше указанный алгоритм найдет решение не более чем за `7 попыток`.

Еще один пример - сколько нужно итераций для того, чтобы пройтись по словарю из 240 000 элементов?

- `Минимум - 1`
- `Максимум - 18`

`А если бы это был обычный алгоритм, то максимум итераций мог бы быть - 240 000`

### 2.Эффективность бинарного алгоритма.
---
В общем случае для списка из n элменетов бинарный поиск выполняется за log n по основанию 2, тогда как просто поиск будет выполнен за n шагов.
Также с возрастанием количества элементов - бинарный алгоритм начинает работать более эффективно.

#### Логарифм

Например - log100 по основанию 10 по сути означает, сколько раз нужно перемножить 10, чтобы получить 100.
`Правильный ответ - 2: 10 * 10;`

Логарифм по смыслу противоположен возведению в степень.
Пример:

- 10 в 2 степени = 100;
- log100 по основанию 10 = 2

### 3. Как применять логарифм для бинарного поиска.
---
1. Для 8 элементов:
- Простой алгоритм - `n = 8`;
- Бинарный алгоритм - `log по основанию 8 = 3`

2. Для 1024 элементов:
- Простой алгоритм - `n = 1024`;
- Бинарный алгоритм - `log по основанию 1024 = 10`;

#### ВАЖНО!!! - бинарный поиск работает только, если список отсортирован!

### 4. О-большое.
---

Для того, чтобы понять самый худший сценарий завершения алгоритма было введено понятие - О-большое.

`О-большое - описывает насколько быстро работает алгоритм. Он описывает за какое МАКСИМАЛЬНОЕ количество итераций алгоритм завершит свою работу`

Например:

О(n) - простой алгоритм выполнит поиск искомого числа за n итераций.
О(log n) - для этого алгоритма потребуется log n итераций.

`Важно! О-большое не считает время выполнения операций, а считает количество итераций`

То есть по факту О-большое сообщает программисту сколько итераций цикла МОЖЕТ БЫТЬ при использовании данного алгоритма, и он будет уверен, что за эти пределы алгоритм не уйдет.

#### Примеры О-большого.

- O(n) - линейное время. Пример: линейный алгоритм.
- O(log n) - логарифмическое время. Пример: бинарный поиск.
- O(n * log n) - эффективные алгоритмы сортировки(быстрая сортировка).
- O(n в квадрате) - медленные алгоритмы сортировки(сортировка выбором).
- О(n!) - очень медленные алгоритмы.

#### Задача о коммивояжоре

В теории вычислений есть нерешённая задача о коммивояжоре, к которой до сих пор не смогли подобрать эффективный алгоритм поиска.

Суть задачи - коммивояжор должен объехать n городов за самое минимальное расстояние.

Ее можно решить алгоритмом O(n!).
Одно из возможных решений - перебрать все возможные комбинации порядка объезда городов.

Все расстояния суммируются, после чего выбирается путь с кратчайшим расстоянием. Для 5 городов можно создать 120 перестановок, поэтому решение задачи для 5 городов потребует 120 операций.

С каждым разом, как мы увеличиваем количество городов - количество операций существенно возрастает. 
Например, если мы попытаемся решить задачу для 100+ городов, то во время его решить не получится, т.к. быстрее Солнце погаснет.