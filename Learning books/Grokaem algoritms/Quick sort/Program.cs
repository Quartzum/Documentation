// Алгоритм быстрой сортировки(алгоритм Хоара).

void Main()
{
    Console.WriteLine("Start algorithm QuickSort");
    int[] array = { 4, -12, 3, 31, 0, 7, 4, 14, 90, 40};
    PrintArray(array);
    array = QuickSort(array, 0, array.Length - 1);
    PrintArray(array);
    Console.WriteLine("End algorithm QuickSort");
}
/*
---------------------------------------------------------------------------------------------------------------------
В метод QuickSort передаем:

- array - массив для сортировки.
- minIndex - минимальный индекс. Это начальная позиция, с которой массив будет отсортирован.
То, что находится до индекса отсортировано не будет.
- maxIndex - максимальный индекс. Это конечная позиция, до которой массив будет отсортирован.
Всё, что находится за индексом отсортировано не будет.
---------------------------------------------------------------------------------------------------------------------
Задача метода:

Вернуть отсортированный массив.
---------------------------------------------------------------------------------------------------------------------
Принцип работы метода:

Т.к. метод рекурсивный, то мы создаем БАЗОВЫЙ и РЕКУРСИВНЫЙ выход:

1. При БАЗОВОМ выходе мы ВОЗВРАЩАЕМ отсортированный массив.

2. В РЕКУРСИВНОМ выходе, если минимальный индекс >= максимальному индексу ВОЗВРАЩАЕМ массив.
Пока все рекурсивные методы не завершат работу - условие будет проверять индексы.

3. В переменной pivot помещается результат работы метода FindPivot.

Вкртаце она делает следующие:
- Ищет опорную позицию, относительно которой слева или справа больше нет необходимости проверять массив для сортировки.
- Позволяет сойтись в равенстве минимальному и максимальному индексу.

4. Вызываем рекурсивно метод QuickSort, который проверяет левую часть массива на наличие неотсортированных значений.
С каждым новым вызовом метода мы уменьшаем размер сортировки массива.
5. Вызываем рекурсивано метод QuickSort, который проверяет правую часть массива на наличие неотсортированных значений.
С каждым новым вызовом метода мы увеличиваем размер сортировки массива.
---------------------------------------------------------------------------------------------------------------------
*/
int[] QuickSort(int[] array, int minIndex, int maxIndex)
{
    if (minIndex >= maxIndex) return array; // Выход из рекурсии.
    int pivot = FindPivot(array, minIndex, maxIndex); // Ищем опорную позицию.
    
    QuickSort(array, minIndex, pivot - 1); // С каждым новым вызовом метода уменьшаем опорную позицию на 1.
    QuickSort(array, pivot + 1, maxIndex); // С каждым новым вызовом метода увеличиваем опорную позицию на 1.

    return array; // Базовый выход.
}
/*
---------------------------------------------------------------------------------------------------------------------
Задача метода:

1.Отсортировать массив в определённом диапазоне.
2.Найти опорную позицию для следующей итерации рекурсивного метода и вернуть его.
---------------------------------------------------------------------------------------------------------------------
Принцип работы FindPivot:

1. Pivot - опорная позиция(изначально равна -1, но меняется в зависимости от входящих данных);
2. Создаем переменную temp для хранения числа при перестановке.
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
3. Цикл:
i = minIndex(приходит из QuickSort)
Пока i < maxIndex(приходит из QuickSort) i++;

На каждой итерации проверяем - если элемент текущего индекса < элемента максимального индекса, то:

- pivot++;
- Помещаем во временное хранилище элемент находящийся на опорной позиции.
- На то место, где была опорная позиция в массиве помещаем элемент находящийся на текущей позиции.
- На текущую позицию - элемент стоявший на опорной позиции.

...иначе:

Пропускаем итерацию.
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
3)После завершения цикла меняем опорный элемент с максимальным элементом местами.

- pivot++;
- Помещаем во временное хранилище элемент находящийся на опорной позиции.
- На то место, где была опорная позиция в массиве помещаем элемент находящийся на максимальной позиции.
- На максимальную позицию - элемент стоявший на опорной позиции.
- возвращаем массив
---------------------------------------------------------------------------------------------------------------------
*/
int FindPivot(int[] array, int minIndex, int maxIndex)
{
    int pivot = minIndex - 1; // Опорная позиция.
    int temp = 0; // Переменная для хранения элемента при перестановки.
    
    for (int i = minIndex; i < maxIndex; i++) // Проверяем все элементы в принятом диапазоне.
    {
        if (array[i] < array[maxIndex]) // Если текущий элемент меньше максимального, то производим перестановку.
        {
            pivot++;
            temp = array[pivot];
            array[pivot] = array[i];
            array[i] = temp;
        }
    }
    // После прохода по массиву меняем опорную позицию с максимальной.
    pivot++;
    temp = array[pivot];
    array[pivot] = array[maxIndex];
    array[maxIndex] = temp;

    return pivot;
}
void PrintArray(int[] array) // Метод печати массива в консоль.
{
    for (int i = 0; i < array.Length; i++)
    {
        Console.Write($"{array[i]} ");
    }
    Console.WriteLine();
}
Main();