1)Типы данных.
==================================================================================================
Значение в JS всегда относятся к какому-то типу данных.
Переменная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число:

// Не будет ошибкой
let message = "hello";
message = 123456;

Языки программирования, в которых такое возможно, называются «динамически типизированными». Это значит,
что типы данных есть, но переменные не привязаны ни к одному из них.

1)Число.
==================================================================================================
let n = 123;
n = 12.345;

Существует множество операций для чисел, например, умножение *, деление /, сложение +, вычитание - и так далее.

Кроме обычных чисел, существуют так называемые «специальные числовые значения»,
которые относятся к этому типу данных: Infinity, -Infinity и NaN.

isNan(); - проверяет является ли параметр NaN.
isFinite(); - проверяет является ли параметр Infinity.

Infinity представляет собой математическую бесконечность. Это особое значение, которое больше любого числа.

Мы можем получить его в результате деления на ноль:

alert( 1 / 0 ); // Infinity
Или задать его явно:

alert( Infinity ); // Infinity
NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:

alert( "не число" / 2 ); // NaN, такое деление является ошибкой
Значение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN:

alert( NaN + 1 ); // NaN
alert( 3 * NaN ); // NaN
alert( "не число" / 2 - 1 ); // NaN
Если где-то в математическом выражении есть NaN, то оно распространяется на весь результат
(есть только одно исключение: NaN ** 0 равно 1).

Математические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль,
обращаться с нечисловыми строками как с числами и т.д.

Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим NaN
как результат выполнения.

Специальные числовые значения относятся к типу «число». Конечно, это не числа в привычном значении этого слова.

Math. - встроенный объект, который содержит продвинутые математичесие функции и константы.
ParseInt("123",10) - преобразование строки в число. Первый параметр строка, второй параметр система исчисления.

2)BigInt.
==================================================================================================
В JavaScript тип «number» не может содержать числа больше, чем (253-1) (т. е. 9007199254740991),
или меньше, чем -(253-1) для отрицательных чисел. Это техническое ограничение вызвано их внутренним представлением.
Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:

// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;

Не поддерживаются в Internet Exploer.

3)Строка.
==================================================================================================
Строка (string) в JavaScript должна быть заключена в кавычки.

let str = "Привет";
let str2 = 'Одинарные кавычки тоже подойдут';
let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;

В JavaScript существует три типа кавычек.

Двойные кавычки: "Привет".
Одинарные кавычки: 'Привет'.
Обратные кавычки: `Привет`.

Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.

Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку,
заключая их в ${…}. Например:

let name = "Иван";

// Вставим переменную
alert( `Привет, ${name}!` ); // Привет, Иван!

// Вставим выражение
alert( `результат: ${1 + 2}` ); // результат: 3

Нет отдельного типа данных для одного символа.
В некоторых языках, например C и Java, для хранения одного символа, например "a" или "%",
существует отдельный тип. В языках C и Java это char.

В JavaScript подобного типа нет, есть только тип string. Строка может содержать ноль символов (быть пустой),
один символ или множество.

Методы для строк:

"hello".length; - количество букв в строке.
"hello".charAt(0); - конкретную букву в строке.
"hello,world!".replace("hello","goodbye"); - меняет слово в строке.
"hello".toUpperCase(); - делает все буквы заглавными(либо конкретную букву).

Мутирование:

const nameName = 144
console.log('Введите данные: ' + nameName)

Здесь произойдет процесс конкатенации. То есть первое значение склеиться со вторым значением.
При этом переменная Name станет строкой, а не числом,как было до этого. 
Это происходит из-за того, что строка главнее числа. 
Есть специальная таблица по которой можно определить важность данных.

4)Булевые(логический)тип.
==================================================================================================
Булевый тип (boolean) может принимать только два значения: true (истина) и false (ложь).

Например:
let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено

Булевые значения также могут быть результатом сравнений:

let isGreater = 4 > 1;

alert( isGreater ); // true (результатом сравнения будет "да")

5)Null.
==================================================================================================
Специальное значение null не относится ни к одному из типов, описанных выше.

Оно формирует отдельный тип, который содержит только значение null:

let age = null;
В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем»,
как в некоторых других языках.

Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

В приведённом выше коде указано, что значение переменной age неизвестно.

6)Undefind.
==================================================================================================
Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null.

Оно означает, что «значение не было присвоено».

Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined:

let age;

alert(age); // выведет "undefined"
Технически мы можем присвоить значение undefined любой переменной:

let age = 123;

// изменяем значение на undefined
age = undefined;

alert(age); // "undefined"
…Но так делать не рекомендуется. Обычно null используется для присвоения переменной «пустого»
или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.

7)Объекты:
==================================================================================================
Тип object (объект) – особенный.

Все остальные типы называются «примитивными», потому что их значениями могут быть только простые
значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или
более сложные структуры.

Примеры объектов:

-Функции
-Массивы
-Даты
-Регулярные выражения

8)Symbol - это уникальное примитивное значение. 
==================================================================================================
Позволяет добавлять уникальное свойство к объекту, с уверенностью,
что он не перезапишет никакое другое свойство.

9)Оператор typeof.
==================================================================================================
Оператор typeof возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения
различных типов по-разному или просто хотим сделать проверку.

У него есть две синтаксические формы:

Синтаксис оператора: typeof x.
Синтаксис функции: typeof(x).
Другими словами, он работает со скобками или без скобок. Результат одинаковый.

Результатом вызова typeof null является "object". Это официально признанная ошибка в typeof,
ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, null
не является объектом. Это специальное значение с отдельным типом.

Вызов typeof alert возвращает "function", потому что alert является функцией. Мы изучим функции в следующих главах,
где заодно увидим, что в JavaScript нет специального типа «функция». Функции относятся к объектному типу. 
Но typeof обрабатывает их особым образом, возвращая "function". Так тоже повелось от создания JavaScript. 
Формально это неверно, но может быть удобным на практике.



